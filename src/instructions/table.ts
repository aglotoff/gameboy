import { RegisterPair, Register, regs } from "../cpu";
import {
  addRegisterPair,
  addToStackPointer,
  decrementRegisterPair,
  incrementRegisterPair,
} from "./arithmetic16";
import {
  addImmediate,
  addImmediateWithCarry,
  addIndirectHL,
  addIndirectHLWithCarry,
  addRegister,
  addRegisterWithCarry,
  andImmediate,
  andIndirectHL,
  andRegister,
  compareImmediate,
  compareIndirectHL,
  compareRegister,
  complementAccumulator,
  complementCarryFlag,
  decimalAdjustAccumulator,
  decrementIndirectHL,
  decrementRegister,
  incrementIndirectHL,
  incrementRegister,
  orImmediate,
  orIndirectHL,
  orRegister,
  setCarryFlag,
  subtractImmediate,
  subtractImmediateWithCarry,
  subtractIndirectHL,
  subtractIndirectHLWithCarry,
  subtractRegister,
  subtractRegisterWithCarry,
  xorImmediate,
  xorIndirectHL,
  xorRegister,
} from "./arithmetic8";
import {
  resetBitIndirectHL,
  resetBitRegister,
  rotateLeftAccumulator,
  rotateLeftCircularAccumulator,
  rotateLeftCircularIndirectHL,
  rotateLeftCircularRegister,
  rotateLeftIndirectHL,
  rotateLeftRegister,
  rotateRightAccumulator,
  rotateRightCircularAccumulator,
  rotateRightCircularIndirectHL,
  rotateRightCircularRegister,
  rotateRightIndirectHL,
  rotateRightRegister,
  shiftLeftArithmeticIndirectHL,
  shiftLeftArithmeticRegister,
  shiftRightArithmeticIndirectHL,
  shiftRightArithmeticRegister,
  shiftRightLogicalIndirectHL,
  shiftRightLogicalRegister,
  swapNibblesIndirectHL,
  swapNibblesRegister,
  testBitIndirectHL,
  testBitRegister,
} from "./bitwise";
import {
  callFunction,
  callFunctionConditional,
  jump,
  jumpConditional,
  jumpToHL,
  relativeJump,
  relativeJumpConditional,
  restartFunction,
  returnFromFunction,
  returnFromFunctionConditional,
  returnFromInterruptHandler,
} from "./flow";
import { fetchImmediateByte, Instruction, InstructionCtx } from "./lib";
import {
  loadDirectFromStackPointer,
  loadHLFromAdjustedStackPointer,
  loadRegisterPair,
  loadStackPointerFromHL,
  popFromStack,
  pushToStack,
} from "./load16";
import {
  loadAccumulatorFromDirectByte,
  loadAccumulatorFromDirectWord,
  loadAccumulatorFromIndirectBC,
  loadAccumulatorFromIndirectC,
  loadAccumulatorFromIndirectDE,
  loadAccumulatorFromIndirectHLDecrement,
  loadAccumulatorFromIndirectHLIncrement,
  loadDirectByteFromAccumulator,
  loadDirectWordFromAccumulator,
  loadIndirectBCFromAccumulator,
  loadIndirectCFromAccumulator,
  loadIndirectDEFromAccumulator,
  loadIndirectHLDecrementFromAccumulator,
  loadIndirectHLFromImmediateData,
  loadIndirectHLFromRegister,
  loadIndirectHLIncrementFromAccumulator,
  loadRegisterFromImmediate,
  loadRegisterFromIndirectHL,
  loadRegisterFromRegister,
} from "./load8";
import {
  disableInterrupts,
  enableInterrupts,
  halt,
  noOperation,
  stop,
} from "./misc";

const instructions: Partial<Record<number, Instruction>> = {
  0x00: ["NOP", noOperation],
  0x01: ["LD BC,d16", (c) => loadRegisterPair(c, RegisterPair.BC)],
  0x02: ["LD (BC),A", loadIndirectBCFromAccumulator],
  0x03: ["INC BC", (c) => incrementRegisterPair(c, RegisterPair.BC)],
  0x04: ["INC B", (c) => incrementRegister(c, Register.B)],
  0x05: ["DEC B", (c) => decrementRegister(c, Register.B)],
  0x06: ["LD B,d8", (c) => loadRegisterFromImmediate(c, Register.B)],
  0x07: ["RLCA", rotateLeftCircularAccumulator],
  0x08: ["LD (a16),SP", loadDirectFromStackPointer],
  0x09: ["ADD HL,BC", (c) => addRegisterPair(c, RegisterPair.BC)],
  0x0a: ["LD A,(BC)", loadAccumulatorFromIndirectBC],
  0x0b: ["DEC BC", (c) => decrementRegisterPair(c, RegisterPair.BC)],
  0x0c: ["INC C", (c) => incrementRegister(c, Register.C)],
  0x0d: ["DEC C", (c) => decrementRegister(c, Register.C)],
  0x0e: ["LD C,d8", (c) => loadRegisterFromImmediate(c, Register.C)],
  0x0f: ["RRCA", rotateRightCircularAccumulator],

  0x10: ["STOP 0", stop],
  0x11: ["LD DE,d16", (c) => loadRegisterPair(c, RegisterPair.DE)],
  0x12: ["LD (DE),A", loadIndirectDEFromAccumulator],
  0x13: ["INC DE", (c) => incrementRegisterPair(c, RegisterPair.DE)],
  0x14: ["INC D", (c) => incrementRegister(c, Register.D)],
  0x15: ["DEC D", (c) => decrementRegister(c, Register.D)],
  0x16: ["LD D,d8", (c) => loadRegisterFromImmediate(c, Register.D)],
  0x17: ["RLA", rotateLeftAccumulator],
  0x18: ["JR r8", relativeJump],
  0x19: ["ADD HL,DE", (c) => addRegisterPair(c, RegisterPair.DE)],
  0x1a: ["LD A,(DE)", loadAccumulatorFromIndirectDE],
  0x1b: ["DEC DE", (c) => decrementRegisterPair(c, RegisterPair.DE)],
  0x1c: ["INC E", (c) => incrementRegister(c, Register.E)],
  0x1d: ["DEC E", (c) => decrementRegister(c, Register.E)],
  0x1e: ["LD E,d8", (c) => loadRegisterFromImmediate(c, Register.E)],
  0x1f: ["RRA", rotateRightAccumulator],

  0x20: ["JR NZ,r8", (c) => relativeJumpConditional(c, "NZ")],
  0x21: ["LD HL,d16", (c) => loadRegisterPair(c, RegisterPair.HL)],
  0x22: ["LD (HL+),A", loadIndirectHLIncrementFromAccumulator],
  0x23: ["INC HL", (c) => incrementRegisterPair(c, RegisterPair.HL)],
  0x24: ["INC H", (c) => incrementRegister(c, Register.H)],
  0x25: ["DEC H", (c) => decrementRegister(c, Register.H)],
  0x26: ["LD H,d8", (c) => loadRegisterFromImmediate(c, Register.H)],
  0x27: ["DAA", decimalAdjustAccumulator],
  0x28: ["JR Z,r8", (c) => relativeJumpConditional(c, "Z")],
  0x29: ["ADD HL,HL", (c) => addRegisterPair(c, RegisterPair.HL)],
  0x2a: ["LD A,(HL+)", loadAccumulatorFromIndirectHLIncrement],
  0x2b: ["DEC HL", (c) => decrementRegisterPair(c, RegisterPair.HL)],
  0x2c: ["INC L", (c) => incrementRegister(c, Register.L)],
  0x2d: ["DEC L", (c) => decrementRegister(c, Register.L)],
  0x2e: ["LD L,d8", (c) => loadRegisterFromImmediate(c, Register.L)],
  0x2f: ["CPL", complementAccumulator],

  0x30: ["JR NC,r8", (c) => relativeJumpConditional(c, "NC")],
  0x31: ["LD SP,d16", (c) => loadRegisterPair(c, RegisterPair.SP)],
  0x32: ["LD (HL-),A", loadIndirectHLDecrementFromAccumulator],
  0x33: ["INC SP", (c) => incrementRegisterPair(c, RegisterPair.SP)],
  0x34: ["INC (HL)", incrementIndirectHL],
  0x35: ["DEC (HL)", decrementIndirectHL],
  0x36: ["LD (HL),d8", loadIndirectHLFromImmediateData],
  0x37: ["SCF", setCarryFlag],
  0x38: ["JR C,r8", (c) => relativeJumpConditional(c, "C")],
  0x39: ["ADD HL,SP", (c) => addRegisterPair(c, RegisterPair.SP)],
  0x3a: ["LD A,(HL-)", loadAccumulatorFromIndirectHLDecrement],
  0x3b: ["DEC SP", (c) => decrementRegisterPair(c, RegisterPair.SP)],
  0x3c: ["INC A", (c) => incrementRegister(c, Register.A)],
  0x3d: ["DEC A", (c) => decrementRegister(c, Register.A)],
  0x3e: ["LD A,d8", (c) => loadRegisterFromImmediate(c, Register.A)],
  0x3f: ["CCF", complementCarryFlag],

  0x40: ["LD B,B", (c) => loadRegisterFromRegister(c, Register.B, Register.B)],
  0x41: ["LD B,C", (c) => loadRegisterFromRegister(c, Register.B, Register.C)],
  0x42: ["LD B,D", (c) => loadRegisterFromRegister(c, Register.B, Register.D)],
  0x43: ["LD B,E", (c) => loadRegisterFromRegister(c, Register.B, Register.E)],
  0x44: ["LD B,H", (c) => loadRegisterFromRegister(c, Register.B, Register.H)],
  0x45: ["LD B,L", (c) => loadRegisterFromRegister(c, Register.B, Register.L)],
  0x46: ["LD B,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.B)],
  0x47: ["LD B,A", (c) => loadRegisterFromRegister(c, Register.B, Register.A)],
  0x48: ["LD C,B", (c) => loadRegisterFromRegister(c, Register.C, Register.B)],
  0x49: ["LD C,C", (c) => loadRegisterFromRegister(c, Register.C, Register.C)],
  0x4a: ["LD C,D", (c) => loadRegisterFromRegister(c, Register.C, Register.D)],
  0x4b: ["LD C,E", (c) => loadRegisterFromRegister(c, Register.C, Register.E)],
  0x4c: ["LD C,H", (c) => loadRegisterFromRegister(c, Register.C, Register.H)],
  0x4d: ["LD C,L", (c) => loadRegisterFromRegister(c, Register.C, Register.L)],
  0x4e: ["LD C,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.C)],
  0x4f: ["LD C,A", (c) => loadRegisterFromRegister(c, Register.C, Register.A)],

  0x50: ["LD D,B", (c) => loadRegisterFromRegister(c, Register.D, Register.B)],
  0x51: ["LD D,C", (c) => loadRegisterFromRegister(c, Register.D, Register.D)],
  0x52: ["LD D,D", (c) => loadRegisterFromRegister(c, Register.D, Register.D)],
  0x53: ["LD D,E", (c) => loadRegisterFromRegister(c, Register.D, Register.E)],
  0x54: ["LD D,H", (c) => loadRegisterFromRegister(c, Register.D, Register.H)],
  0x55: ["LD D,L", (c) => loadRegisterFromRegister(c, Register.L, Register.D)],
  0x56: ["LD D,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.D)],
  0x57: ["LD D,A", (c) => loadRegisterFromRegister(c, Register.D, Register.A)],
  0x58: ["LD E,B", (c) => loadRegisterFromRegister(c, Register.E, Register.B)],
  0x59: ["LD E,C", (c) => loadRegisterFromRegister(c, Register.E, Register.C)],
  0x5a: ["LD E,D", (c) => loadRegisterFromRegister(c, Register.E, Register.D)],
  0x5b: ["LD E,E", (c) => loadRegisterFromRegister(c, Register.E, Register.E)],
  0x5c: ["LD E,H", (c) => loadRegisterFromRegister(c, Register.E, Register.H)],
  0x5d: ["LD E,L", (c) => loadRegisterFromRegister(c, Register.E, Register.L)],
  0x5e: ["LD E,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.E)],
  0x5f: ["LD E,A", (c) => loadRegisterFromRegister(c, Register.E, Register.A)],

  0x60: ["LD H,B", (c) => loadRegisterFromRegister(c, Register.H, Register.B)],
  0x61: ["LD H,C", (c) => loadRegisterFromRegister(c, Register.H, Register.C)],
  0x62: ["LD H,D", (c) => loadRegisterFromRegister(c, Register.H, Register.D)],
  0x63: ["LD H,E", (c) => loadRegisterFromRegister(c, Register.H, Register.E)],
  0x64: ["LD H,H", (c) => loadRegisterFromRegister(c, Register.H, Register.H)],
  0x65: ["LD H,L", (c) => loadRegisterFromRegister(c, Register.H, Register.L)],
  0x66: ["LD H,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.H)],
  0x67: ["LD H,A", (c) => loadRegisterFromRegister(c, Register.H, Register.A)],
  0x68: ["LD L,B", (c) => loadRegisterFromRegister(c, Register.L, Register.B)],
  0x69: ["LD L,C", (c) => loadRegisterFromRegister(c, Register.L, Register.C)],
  0x6a: ["LD L,D", (c) => loadRegisterFromRegister(c, Register.L, Register.D)],
  0x6b: ["LD L,E", (c) => loadRegisterFromRegister(c, Register.L, Register.E)],
  0x6c: ["LD L,H", (c) => loadRegisterFromRegister(c, Register.L, Register.H)],
  0x6d: ["LD L,L", (c) => loadRegisterFromRegister(c, Register.L, Register.L)],
  0x6e: ["LD L,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.L)],
  0x6f: ["LD L,A", (c) => loadRegisterFromRegister(c, Register.L, Register.A)],

  0x70: ["LD (HL),B", (c) => loadIndirectHLFromRegister(c, Register.B)],
  0x71: ["LD (HL),C", (c) => loadIndirectHLFromRegister(c, Register.C)],
  0x72: ["LD (HL),D", (c) => loadIndirectHLFromRegister(c, Register.D)],
  0x73: ["LD (HL),E", (c) => loadIndirectHLFromRegister(c, Register.E)],
  0x74: ["LD (HL),H", (c) => loadIndirectHLFromRegister(c, Register.H)],
  0x75: ["LD (HL),L", (c) => loadIndirectHLFromRegister(c, Register.L)],
  0x76: ["HALT", halt],
  0x77: ["LD (HL),A", (c) => loadIndirectHLFromRegister(c, Register.A)],
  0x78: ["LD A,B", (c) => loadRegisterFromRegister(c, Register.A, Register.B)],
  0x79: ["LD A,C", (c) => loadRegisterFromRegister(c, Register.A, Register.C)],
  0x7a: ["LD A,D", (c) => loadRegisterFromRegister(c, Register.A, Register.D)],
  0x7b: ["LD A,E", (c) => loadRegisterFromRegister(c, Register.A, Register.E)],
  0x7c: ["LD A,H", (c) => loadRegisterFromRegister(c, Register.A, Register.H)],
  0x7d: ["LD A,L", (c) => loadRegisterFromRegister(c, Register.A, Register.L)],
  0x7e: ["LD A,(HL)", (c) => loadRegisterFromIndirectHL(c, Register.A)],
  0x7f: ["LD A,A", (c) => loadRegisterFromRegister(c, Register.A, Register.A)],

  0x80: ["ADD A,B", (c) => addRegister(c, Register.B)],
  0x81: ["ADD A,C", (c) => addRegister(c, Register.C)],
  0x82: ["ADD A,D", (c) => addRegister(c, Register.D)],
  0x83: ["ADD A,E", (c) => addRegister(c, Register.E)],
  0x84: ["ADD A,H", (c) => addRegister(c, Register.H)],
  0x85: ["ADD A,L", (c) => addRegister(c, Register.L)],
  0x86: ["ADD A,(HL)", addIndirectHL],
  0x87: ["ADD A,A", (c) => addRegister(c, Register.A)],
  0x88: ["ADC A,B", (c) => addRegisterWithCarry(c, Register.B)],
  0x89: ["ADC A,C", (c) => addRegisterWithCarry(c, Register.C)],
  0x8a: ["ADC A,D", (c) => addRegisterWithCarry(c, Register.D)],
  0x8b: ["ADC A,E", (c) => addRegisterWithCarry(c, Register.E)],
  0x8c: ["ADC A,H", (c) => addRegisterWithCarry(c, Register.H)],
  0x8d: ["ADC A,L", (c) => addRegisterWithCarry(c, Register.L)],
  0x8e: ["ADC A,(HL)", addIndirectHLWithCarry],
  0x8f: ["ADC A,A", (c) => addRegisterWithCarry(c, Register.A)],

  0x90: ["SUB B", (c) => subtractRegister(c, Register.B)],
  0x91: ["SUB C", (c) => subtractRegister(c, Register.C)],
  0x92: ["SUB D", (c) => subtractRegister(c, Register.D)],
  0x93: ["SUB E", (c) => subtractRegister(c, Register.E)],
  0x94: ["SUB H", (c) => subtractRegister(c, Register.H)],
  0x95: ["SUB L", (c) => subtractRegister(c, Register.L)],
  0x96: ["SUB (HL)", subtractIndirectHL],
  0x97: ["SUB A", (c) => subtractRegister(c, Register.A)],
  0x98: ["SBC A,B", (c) => subtractRegisterWithCarry(c, Register.B)],
  0x99: ["SBC A,C", (c) => subtractRegisterWithCarry(c, Register.C)],
  0x9a: ["SBC A,D", (c) => subtractRegisterWithCarry(c, Register.D)],
  0x9b: ["SBC A,E", (c) => subtractRegisterWithCarry(c, Register.E)],
  0x9c: ["SBC A,H", (c) => subtractRegisterWithCarry(c, Register.H)],
  0x9d: ["SBC A,L", (c) => subtractRegisterWithCarry(c, Register.L)],
  0x9e: ["SBC A,(HL)", subtractIndirectHLWithCarry],
  0x9f: ["SBC A,A", (c) => subtractRegisterWithCarry(c, Register.A)],

  0xa0: ["AND B", (c) => andRegister(c, Register.B)],
  0xa1: ["AND C", (c) => andRegister(c, Register.C)],
  0xa2: ["AND D", (c) => andRegister(c, Register.D)],
  0xa3: ["AND E", (c) => andRegister(c, Register.E)],
  0xa4: ["AND H", (c) => andRegister(c, Register.H)],
  0xa5: ["AND L", (c) => andRegister(c, Register.L)],
  0xa6: ["AND (HL)", andIndirectHL],
  0xa7: ["AND A", (c) => andRegister(c, Register.A)],
  0xa8: ["XOR B", (c) => xorRegister(c, Register.B)],
  0xa9: ["XOR C", (c) => xorRegister(c, Register.C)],
  0xaa: ["XOR D", (c) => xorRegister(c, Register.D)],
  0xab: ["XOR E", (c) => xorRegister(c, Register.E)],
  0xac: ["XOR H", (c) => xorRegister(c, Register.H)],
  0xad: ["XOR L", (c) => xorRegister(c, Register.L)],
  0xae: ["XOR (HL)", xorIndirectHL],
  0xaf: ["XOR A", (c) => xorRegister(c, Register.A)],

  0xb0: ["OR B", (c) => orRegister(c, Register.B)],
  0xb1: ["OR C", (c) => orRegister(c, Register.C)],
  0xb2: ["OR D", (c) => orRegister(c, Register.D)],
  0xb3: ["OR E", (c) => orRegister(c, Register.E)],
  0xb4: ["OR H", (c) => orRegister(c, Register.H)],
  0xb5: ["OR L", (c) => orRegister(c, Register.L)],
  0xb6: ["OR (HL)", orIndirectHL],
  0xb7: ["OR A", (c) => orRegister(c, Register.A)],
  0xb8: ["CP B", (c) => compareRegister(c, Register.B)],
  0xb9: ["CP C", (c) => compareRegister(c, Register.C)],
  0xba: ["CP D", (c) => compareRegister(c, Register.D)],
  0xbb: ["CP E", (c) => compareRegister(c, Register.E)],
  0xbc: ["CP H", (c) => compareRegister(c, Register.H)],
  0xbd: ["CP L", (c) => compareRegister(c, Register.L)],
  0xbe: ["CP (HL)", compareIndirectHL],
  0xbf: ["CP A", (c) => compareRegister(c, Register.A)],

  0xc0: ["RET NZ", (c) => returnFromFunctionConditional(c, "NZ")],
  0xc1: ["POP BC", (c) => popFromStack(c, RegisterPair.BC)],
  0xc2: ["JP NZ,a16", (c) => jumpConditional(c, "NZ")],
  0xc3: ["JP a16", jump],
  0xc4: ["CALL NZ,a16", (c) => callFunctionConditional(c, "NZ")],
  0xc5: ["PUSH BC", (c) => pushToStack(c, RegisterPair.BC)],
  0xc6: ["ADD A,d8", addImmediate],
  0xc7: ["RST 00H", (c) => restartFunction(c, 0x00)],
  0xc8: ["RET Z", (c) => returnFromFunctionConditional(c, "Z")],
  0xc9: ["RET", returnFromFunction],
  0xca: ["JP Z,a16", (c) => jumpConditional(c, "Z")],
  // 0xcb: prefix CB
  0xcc: ["CALL Z,a16", (c) => callFunctionConditional(c, "Z")],
  0xcd: ["CALL a16", callFunction],
  0xce: ["ADC A,d8", addImmediateWithCarry],
  0xcf: ["RST 08H", (c) => restartFunction(c, 0x08)],

  0xd0: ["RET NC", (c) => returnFromFunctionConditional(c, "NC")],
  0xd1: ["POP BC", (c) => popFromStack(c, RegisterPair.DE)],
  0xd2: ["JP NC,a16", (c) => jumpConditional(c, "NC")],
  0xd4: ["CALL NC,a16", (c) => callFunctionConditional(c, "NC")],
  0xd5: ["PUSH DE", (c) => pushToStack(c, RegisterPair.DE)],
  0xd6: ["SUB d8", subtractImmediate],
  0xd7: ["RST 10H", (c) => restartFunction(c, 0x10)],
  0xd8: ["RET C", (c) => returnFromFunctionConditional(c, "C")],
  0xd9: ["RETI", returnFromInterruptHandler],
  0xda: ["JP C,a16", (c) => jumpConditional(c, "C")],
  0xdc: ["CALL C,a16", (c) => callFunctionConditional(c, "C")],
  0xde: ["SBC A,d8", subtractImmediateWithCarry],
  0xdf: ["RST 18H", (c) => restartFunction(c, 0x18)],

  0xe0: ["LDH (a8),A", loadDirectByteFromAccumulator],
  0xe1: ["POP BC", (c) => popFromStack(c, RegisterPair.HL)],
  0xe2: ["LD (C),A", loadIndirectCFromAccumulator],
  0xe5: ["PUSH HL", (c) => pushToStack(c, RegisterPair.HL)],
  0xe6: ["AND d8", andImmediate],
  0xe7: ["RST 20H", (c) => restartFunction(c, 0x20)],
  0xe8: ["ADD SP,r8", addToStackPointer],
  0xe9: ["JP (HL)", jumpToHL],
  0xea: ["LD (a16),A", loadDirectWordFromAccumulator],
  0xee: ["XOR d8", xorImmediate],
  0xef: ["RST 28H", (c) => restartFunction(c, 0x28)],

  0xf0: ["LDH A,(a8)", loadAccumulatorFromDirectByte],
  0xf1: ["POP AF", (c) => popFromStack(c, RegisterPair.AF)],
  0xf2: ["LD A,(C)", loadAccumulatorFromIndirectC],
  0xf3: ["DI", disableInterrupts],
  0xf5: ["PUSH AF", (c) => pushToStack(c, RegisterPair.AF)],
  0xf6: ["AND d8", orImmediate],
  0xf7: ["RST 30H", (c) => restartFunction(c, 0x30)],
  0xf8: ["LD HL,SP+r8", loadHLFromAdjustedStackPointer],
  0xf9: ["LD SP,HL", loadStackPointerFromHL],
  0xfa: ["LD A,(a16)", loadAccumulatorFromDirectWord],
  0xfb: ["EI", enableInterrupts],
  0xfe: ["CP d8", compareImmediate],
  0xff: ["RST 38H", (c) => restartFunction(c, 0x38)],
};

export const prefixCBInstructions: Partial<Record<number, Instruction>> = {
  0x00: ["RLC B", (c) => rotateLeftCircularRegister(c, Register.B)],
  0x01: ["RLC C", (c) => rotateLeftCircularRegister(c, Register.C)],
  0x02: ["RLC D", (c) => rotateLeftCircularRegister(c, Register.D)],
  0x03: ["RLC E", (c) => rotateLeftCircularRegister(c, Register.E)],
  0x04: ["RLC H", (c) => rotateLeftCircularRegister(c, Register.H)],
  0x05: ["RLC L", (c) => rotateLeftCircularRegister(c, Register.L)],
  0x06: ["RLC (HL)", rotateLeftCircularIndirectHL],
  0x07: ["RLC A", (c) => rotateLeftCircularRegister(c, Register.A)],
  0x08: ["RRC B", (c) => rotateRightCircularRegister(c, Register.B)],
  0x09: ["RRC C", (c) => rotateRightCircularRegister(c, Register.C)],
  0x0a: ["RRC D", (c) => rotateRightCircularRegister(c, Register.D)],
  0x0b: ["RRC E", (c) => rotateRightCircularRegister(c, Register.E)],
  0x0c: ["RRC H", (c) => rotateRightCircularRegister(c, Register.H)],
  0x0d: ["RRC L", (c) => rotateRightCircularRegister(c, Register.L)],
  0x0e: ["RRC (HL)", rotateRightCircularIndirectHL],
  0x0f: ["RRC A", (c) => rotateRightCircularRegister(c, Register.A)],

  0x10: ["RL B", (c) => rotateLeftRegister(c, Register.B)],
  0x11: ["RL C", (c) => rotateLeftRegister(c, Register.C)],
  0x12: ["RL D", (c) => rotateLeftRegister(c, Register.D)],
  0x13: ["RL E", (c) => rotateLeftRegister(c, Register.E)],
  0x14: ["RL H", (c) => rotateLeftRegister(c, Register.H)],
  0x15: ["RL L", (c) => rotateLeftRegister(c, Register.L)],
  0x16: ["RL (HL)", rotateLeftIndirectHL],
  0x17: ["RL A", (c) => rotateLeftRegister(c, Register.A)],
  0x18: ["RR B", (c) => rotateRightRegister(c, Register.B)],
  0x19: ["RR C", (c) => rotateRightRegister(c, Register.C)],
  0x1a: ["RR D", (c) => rotateRightRegister(c, Register.D)],
  0x1b: ["RR E", (c) => rotateRightRegister(c, Register.E)],
  0x1c: ["RR H", (c) => rotateRightRegister(c, Register.H)],
  0x1d: ["RR L", (c) => rotateRightRegister(c, Register.L)],
  0x1e: ["RR (HL)", rotateRightIndirectHL],
  0x1f: ["RR A", (c) => rotateRightRegister(c, Register.A)],

  0x20: ["SLA B", (c) => shiftLeftArithmeticRegister(c, Register.B)],
  0x21: ["SLA C", (c) => shiftLeftArithmeticRegister(c, Register.C)],
  0x22: ["SLA D", (c) => shiftLeftArithmeticRegister(c, Register.D)],
  0x23: ["SLA E", (c) => shiftLeftArithmeticRegister(c, Register.E)],
  0x24: ["SLA H", (c) => shiftLeftArithmeticRegister(c, Register.H)],
  0x25: ["SLA L", (c) => shiftLeftArithmeticRegister(c, Register.L)],
  0x26: ["SLA (HL)", shiftLeftArithmeticIndirectHL],
  0x27: ["SLA A", (c) => shiftLeftArithmeticRegister(c, Register.A)],
  0x28: ["SRA B", (c) => shiftRightArithmeticRegister(c, Register.B)],
  0x29: ["SRA C", (c) => shiftRightArithmeticRegister(c, Register.C)],
  0x2a: ["SRA D", (c) => shiftRightArithmeticRegister(c, Register.D)],
  0x2b: ["SRA E", (c) => shiftRightArithmeticRegister(c, Register.E)],
  0x2c: ["SRA H", (c) => shiftRightArithmeticRegister(c, Register.H)],
  0x2d: ["SRA L", (c) => shiftRightArithmeticRegister(c, Register.L)],
  0x2e: ["SRA (HL)", shiftRightArithmeticIndirectHL],
  0x2f: ["SRA A", (c) => shiftRightArithmeticRegister(c, Register.A)],

  0x30: ["SWAP B", (c) => swapNibblesRegister(c, Register.B)],
  0x31: ["SWAP C", (c) => swapNibblesRegister(c, Register.C)],
  0x32: ["SWAP D", (c) => swapNibblesRegister(c, Register.D)],
  0x33: ["SWAP E", (c) => swapNibblesRegister(c, Register.E)],
  0x34: ["SWAP H", (c) => swapNibblesRegister(c, Register.H)],
  0x35: ["SWAP L", (c) => swapNibblesRegister(c, Register.L)],
  0x36: ["SWAP (HL)", swapNibblesIndirectHL],
  0x37: ["SWAP A", (c) => swapNibblesRegister(c, Register.A)],
  0x38: ["SRL B", (c) => shiftRightLogicalRegister(c, Register.B)],
  0x39: ["SRL C", (c) => shiftRightLogicalRegister(c, Register.C)],
  0x3a: ["SRL D", (c) => shiftRightLogicalRegister(c, Register.D)],
  0x3b: ["SRL E", (c) => shiftRightLogicalRegister(c, Register.E)],
  0x3c: ["SRL H", (c) => shiftRightLogicalRegister(c, Register.H)],
  0x3d: ["SRL L", (c) => shiftRightLogicalRegister(c, Register.L)],
  0x3e: ["SRL (HL)", shiftRightLogicalIndirectHL],
  0x3f: ["SRL A", (c) => shiftRightLogicalRegister(c, Register.A)],

  0x40: ["BIT 0,B", (c) => testBitRegister(c, 0, Register.B)],
  0x41: ["BIT 0,C", (c) => testBitRegister(c, 0, Register.C)],
  0x42: ["BIT 0,D", (c) => testBitRegister(c, 0, Register.D)],
  0x43: ["BIT 0,E", (c) => testBitRegister(c, 0, Register.E)],
  0x44: ["BIT 0,H", (c) => testBitRegister(c, 0, Register.H)],
  0x45: ["BIT 0,L", (c) => testBitRegister(c, 0, Register.L)],
  0x46: ["BIT 0,(HL)", (c) => testBitIndirectHL(c, 0)],
  0x47: ["BIT 0,A", (c) => testBitRegister(c, 0, Register.A)],
  0x48: ["BIT 1,B", (c) => testBitRegister(c, 1, Register.B)],
  0x49: ["BIT 1,C", (c) => testBitRegister(c, 1, Register.D)],
  0x4a: ["BIT 1,D", (c) => testBitRegister(c, 1, Register.D)],
  0x4b: ["BIT 1,E", (c) => testBitRegister(c, 1, Register.E)],
  0x4c: ["BIT 1,H", (c) => testBitRegister(c, 1, Register.H)],
  0x4d: ["BIT 1,L", (c) => testBitRegister(c, 1, Register.L)],
  0x4e: ["BIT 1,(HL)", (c) => testBitIndirectHL(c, 1)],
  0x4f: ["BIT 1,A", (c) => testBitRegister(c, 1, Register.A)],

  0x50: ["BIT 2,B", (c) => testBitRegister(c, 2, Register.B)],
  0x51: ["BIT 2,C", (c) => testBitRegister(c, 2, Register.C)],
  0x52: ["BIT 2,D", (c) => testBitRegister(c, 2, Register.D)],
  0x53: ["BIT 2,E", (c) => testBitRegister(c, 2, Register.E)],
  0x54: ["BIT 2,H", (c) => testBitRegister(c, 2, Register.H)],
  0x55: ["BIT 2,L", (c) => testBitRegister(c, 2, Register.L)],
  0x56: ["BIT 2,(HL)", (c) => testBitIndirectHL(c, 2)],
  0x57: ["BIT 2,A", (c) => testBitRegister(c, 2, Register.A)],
  0x58: ["BIT 3,B", (c) => testBitRegister(c, 3, Register.B)],
  0x59: ["BIT 3,C", (c) => testBitRegister(c, 3, Register.C)],
  0x5a: ["BIT 3,D", (c) => testBitRegister(c, 3, Register.D)],
  0x5b: ["BIT 3,E", (c) => testBitRegister(c, 3, Register.E)],
  0x5c: ["BIT 3,H", (c) => testBitRegister(c, 3, Register.H)],
  0x5d: ["BIT 3,L", (c) => testBitRegister(c, 3, Register.L)],
  0x5e: ["BIT 3,(HL)", (c) => testBitIndirectHL(c, 3)],
  0x5f: ["BIT 3,A", (c) => testBitRegister(c, 3, Register.A)],

  0x60: ["BIT 4,B", (c) => testBitRegister(c, 4, Register.B)],
  0x61: ["BIT 4,C", (c) => testBitRegister(c, 4, Register.C)],
  0x62: ["BIT 4,D", (c) => testBitRegister(c, 4, Register.D)],
  0x63: ["BIT 4,E", (c) => testBitRegister(c, 4, Register.E)],
  0x64: ["BIT 4,H", (c) => testBitRegister(c, 4, Register.H)],
  0x65: ["BIT 4,L", (c) => testBitRegister(c, 4, Register.L)],
  0x66: ["BIT 4,(HL)", (c) => testBitIndirectHL(c, 4)],
  0x67: ["BIT 4,A", (c) => testBitRegister(c, 4, Register.A)],
  0x68: ["BIT 5,B", (c) => testBitRegister(c, 5, Register.B)],
  0x69: ["BIT 5,C", (c) => testBitRegister(c, 5, Register.C)],
  0x6a: ["BIT 5,D", (c) => testBitRegister(c, 5, Register.D)],
  0x6b: ["BIT 5,E", (c) => testBitRegister(c, 5, Register.E)],
  0x6c: ["BIT 5,H", (c) => testBitRegister(c, 5, Register.H)],
  0x6d: ["BIT 5,L", (c) => testBitRegister(c, 5, Register.L)],
  0x6e: ["BIT 5,(HL)", (c) => testBitIndirectHL(c, 5)],
  0x6f: ["BIT 5,A", (c) => testBitRegister(c, 5, Register.A)],

  0x70: ["BIT 6,B", (c) => testBitRegister(c, 6, Register.B)],
  0x71: ["BIT 6,C", (c) => testBitRegister(c, 6, Register.C)],
  0x72: ["BIT 6,D", (c) => testBitRegister(c, 6, Register.D)],
  0x73: ["BIT 6,E", (c) => testBitRegister(c, 6, Register.E)],
  0x74: ["BIT 6,H", (c) => testBitRegister(c, 6, Register.H)],
  0x75: ["BIT 6,L", (c) => testBitRegister(c, 6, Register.L)],
  0x76: ["BIT 6,(HL)", (c) => testBitIndirectHL(c, 6)],
  0x77: ["BIT 6,A", (c) => testBitRegister(c, 6, Register.A)],
  0x78: ["BIT 7,B", (c) => testBitRegister(c, 7, Register.B)],
  0x79: ["BIT 7,C", (c) => testBitRegister(c, 7, Register.C)],
  0x7a: ["BIT 7,D", (c) => testBitRegister(c, 7, Register.D)],
  0x7b: ["BIT 7,E", (c) => testBitRegister(c, 7, Register.E)],
  0x7c: ["BIT 7,H", (c) => testBitRegister(c, 7, Register.H)],
  0x7d: ["BIT 7,L", (c) => testBitRegister(c, 7, Register.L)],
  0x7e: ["BIT 7,(HL)", (c) => testBitIndirectHL(c, 7)],
  0x7f: ["BIT 7,A", (c) => testBitRegister(c, 7, Register.A)],

  0x80: ["RES 0,B", (c) => resetBitRegister(c, 0, Register.B)],
  0x81: ["RES 0,C", (c) => resetBitRegister(c, 0, Register.C)],
  0x82: ["RES 0,D", (c) => resetBitRegister(c, 0, Register.D)],
  0x83: ["RES 0,E", (c) => resetBitRegister(c, 0, Register.E)],
  0x84: ["RES 0,H", (c) => resetBitRegister(c, 0, Register.H)],
  0x85: ["RES 0,L", (c) => resetBitRegister(c, 0, Register.L)],
  0x86: ["RES 0,(HL)", (c) => resetBitIndirectHL(c, 0)],
  0x87: ["RES 0,A", (c) => resetBitRegister(c, 0, Register.A)],
  0x88: ["RES 1,B", (c) => resetBitRegister(c, 1, Register.B)],
  0x89: ["RES 1,C", (c) => resetBitRegister(c, 1, Register.C)],
  0x8a: ["RES 1,D", (c) => resetBitRegister(c, 1, Register.D)],
  0x8b: ["RES 1,E", (c) => resetBitRegister(c, 1, Register.E)],
  0x8c: ["RES 1,H", (c) => resetBitRegister(c, 1, Register.H)],
  0x8d: ["RES 1,L", (c) => resetBitRegister(c, 1, Register.L)],
  0x8e: ["RES 1,(HL)", (c) => resetBitIndirectHL(c, 1)],
  0x8f: ["RES 1,A", (c) => resetBitRegister(c, 1, Register.A)],

  0x90: ["RES 2,B", (c) => resetBitRegister(c, 2, Register.B)],
  0x91: ["RES 2,C", (c) => resetBitRegister(c, 2, Register.C)],
  0x92: ["RES 2,D", (c) => resetBitRegister(c, 2, Register.D)],
  0x93: ["RES 2,E", (c) => resetBitRegister(c, 2, Register.E)],
  0x94: ["RES 2,H", (c) => resetBitRegister(c, 2, Register.H)],
  0x95: ["RES 2,L", (c) => resetBitRegister(c, 2, Register.L)],
  0x96: ["RES 2,(HL)", (c) => resetBitIndirectHL(c, 2)],
  0x97: ["RES 2,A", (c) => resetBitRegister(c, 2, Register.A)],
  0x98: ["RES 3,B", (c) => resetBitRegister(c, 3, Register.B)],
  0x99: ["RES 3,C", (c) => resetBitRegister(c, 3, Register.C)],
  0x9a: ["RES 3,D", (c) => resetBitRegister(c, 3, Register.D)],
  0x9b: ["RES 3,E", (c) => resetBitRegister(c, 3, Register.E)],
  0x9c: ["RES 3,H", (c) => resetBitRegister(c, 3, Register.H)],
  0x9d: ["RES 3,L", (c) => resetBitRegister(c, 3, Register.L)],
  0x9e: ["RES 3,(HL)", (c) => resetBitIndirectHL(c, 3)],
  0x9f: ["RES 3,A", (c) => resetBitRegister(c, 3, Register.A)],

  0xa0: ["RES 4,B", (c) => resetBitRegister(c, 4, Register.B)],
  0xa1: ["RES 4,C", (c) => resetBitRegister(c, 4, Register.C)],
  0xa2: ["RES 4,D", (c) => resetBitRegister(c, 4, Register.D)],
  0xa3: ["RES 4,E", (c) => resetBitRegister(c, 4, Register.E)],
  0xa4: ["RES 4,H", (c) => resetBitRegister(c, 4, Register.H)],
  0xa5: ["RES 4,L", (c) => resetBitRegister(c, 4, Register.L)],
  0xa6: ["RES 4,(HL)", (c) => resetBitIndirectHL(c, 4)],
  0xa7: ["RES 4,A", (c) => resetBitRegister(c, 4, Register.A)],
  0xa8: ["RES 5,B", (c) => resetBitRegister(c, 5, Register.B)],
  0xa9: ["RES 5,C", (c) => resetBitRegister(c, 5, Register.C)],
  0xaa: ["RES 5,D", (c) => resetBitRegister(c, 5, Register.D)],
  0xab: ["RES 5,E", (c) => resetBitRegister(c, 5, Register.E)],
  0xac: ["RES 5,H", (c) => resetBitRegister(c, 5, Register.H)],
  0xad: ["RES 5,L", (c) => resetBitRegister(c, 5, Register.L)],
  0xae: ["RES 5,(HL)", (c) => resetBitIndirectHL(c, 5)],
  0xaf: ["RES 5,A", (c) => resetBitRegister(c, 5, Register.A)],

  0xb0: ["RES 6,B", (c) => resetBitRegister(c, 6, Register.B)],
  0xb1: ["RES 6,C", (c) => resetBitRegister(c, 6, Register.C)],
  0xb2: ["RES 6,D", (c) => resetBitRegister(c, 6, Register.D)],
  0xb3: ["RES 6,E", (c) => resetBitRegister(c, 6, Register.E)],
  0xb4: ["RES 6,H", (c) => resetBitRegister(c, 6, Register.H)],
  0xb5: ["RES 6,L", (c) => resetBitRegister(c, 6, Register.L)],
  0xb6: ["RES 6,(HL)", (c) => resetBitIndirectHL(c, 6)],
  0xb7: ["RES 6,A", (c) => resetBitRegister(c, 6, Register.A)],
  0xb8: ["RES 7,B", (c) => resetBitRegister(c, 7, Register.B)],
  0xb9: ["RES 7,C", (c) => resetBitRegister(c, 7, Register.C)],
  0xba: ["RES 7,D", (c) => resetBitRegister(c, 7, Register.D)],
  0xbb: ["RES 7,E", (c) => resetBitRegister(c, 7, Register.E)],
  0xbc: ["RES 7,H", (c) => resetBitRegister(c, 7, Register.H)],
  0xbd: ["RES 7,L", (c) => resetBitRegister(c, 7, Register.L)],
  0xbe: ["RES 7,(HL)", (c) => resetBitIndirectHL(c, 7)],
  0xbf: ["RES 7,A", (c) => resetBitRegister(c, 7, Register.A)],
};

export const nextInstruction = (ctx: InstructionCtx) => {
  const opcode = fetchImmediateByte(ctx);

  const instruction = instructions[opcode];

  if (!instruction) {
    throw new Error(`Invalid opcode ${opcode.toString(16)}`);
  }

  return instruction;
};

export function execNextInstruction(ctx: InstructionCtx) {
  const instruction = nextInstruction(ctx);

  console.log(
    "Executing instruction",
    instruction[0],
    " at ",
    (regs.readPair(RegisterPair.PC) - 1).toString(16)
  );

  return instruction[1](ctx);
}
